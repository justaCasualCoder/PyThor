{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Installation","text":"<p>You can install PyThor using pip: <pre><code>git clone https://github.com/justaCasualCoder/pythor.git\ncd pythor\npip install .\n</code></pre></p>"},{"location":"reference/","title":"API Reference","text":"Source code in <code>pythor/pythor.py</code> <pre><code>class PyThor:\n    def __init__(self):\n        self.dev = None\n        self.session_started = False\n        self.t_flash_enabled = False\n        self.flashpacketsize = int\n        self.sequencesize = int\n        self.partitions = {}\n\n    def connect(self):\n        \"\"\"Connects to Samsung Device\"\"\"\n        self.dev = usb.core.find(idVendor=0x04E8)\n        if self.dev is None:\n            raise ValueError(\"Could not find a Samsung device\")\n        self.dev.set_configuration()\n\n    def pack(self, data, offset, buf):\n        \"\"\"\n        Packs data into buffer\n\n        - `data`: The data to add to buffer\n        - `offset`: Offset of the data in the buffer\n        - `buf`: Buffer to add data to.\n        \"\"\"\n        struct.pack_into(\"i\", buf, offset, data)\n\n    def write(self, data):\n        \"\"\"\n        Writes data to device\n\n        - `data`: Data to send to device\n        \"\"\"\n        if self.dev and self.session_started:\n            self.dev.write(0x1, data)\n        else:\n            raise ValueError(\"You need to start a session first\")\n\n    def read(self, timeout: int = None):\n        \"\"\"\n        Read data from device\n\n        - `timeout` (optional): read timeout in ms.\n        \"\"\"\n        if self.dev and self.session_started:\n            ret = self.dev.read(0x81, 0x1000, timeout)\n            return ret\n        else:\n            raise ValueError(\"You need to start a session first\")\n\n    def print_pit(self):\n        \"\"\"Print PIT of device\"\"\"\n        tree = Tree()\n        root = tree.create_node(\"Partitions\")\n        if not self.partitions:\n            self.get_pit()\n        for partition, attributes in self.partitions.items():\n            node = tree.create_node(partition, parent=root)\n            for key, value in attributes.items():\n                tree.create_node(f\"{key}: {value}\", parent=node)\n        print(tree.show(stdout=False))\n\n    def get_pit(self):\n        \"\"\"\n        Read PIT from device\n\n        Returns:\n            pit_data (bytearray): PIT Data\n        \"\"\"\n        # Request PIT dump\n        buf = bytearray(1024)\n        self.pack(0x65, 0, buf)\n        self.pack(0x01, 4, buf)\n        self.write(buf)\n        ret = self.read()\n        size = struct.unpack_from(\"&lt;I\", ret, 4)[0]\n        blocks = math.ceil(size / 500)\n        logging.debug(f\"PIT size is {size}, {blocks} total blocks\")\n        pit_buf = bytearray(size)\n        for i in range(blocks):\n            buf = bytearray(1024)\n            self.pack(0x65, 0, buf)\n            self.pack(0x02, 4, buf)\n            self.pack(i, 8, buf)\n            self.write(buf)\n            ret = self.read()\n            pit_buf[i * 500 : i * 500 + len(ret)] = ret\n        # Send PIT finish\n        buf = bytearray(1024)\n        self.pack(0x65, 0, buf)\n        self.pack(0x03, 4, buf)\n        # Read ZLP\n        try:\n            self.read()\n        except usb.USBError:\n            # This is fine.\n            pass\n        self.write(buf)\n        self.read()\n        self.parse_pit(pit_buf)\n        return pit_buf\n\n    def parse_pit(self, pit: bytearray):\n        \"\"\"\n        Parse PIT\n\n        Arguments:\n\n        - `pit`: Pit data.\n        \"\"\"\n        with BytesIO(pit) as reader:\n            magic_number = struct.unpack(\"&lt;I\", reader.read(4))[0]\n            if magic_number != 0x12349876:\n                raise ValueError(\"Magic Number Mismatch\")\n            entries = struct.unpack(\"&lt;I\", reader.read(4))[0]\n            unknown = reader.read(8).decode(\"utf-8\")\n            project = reader.read(8).decode(\"utf-8\")\n            reserved = struct.unpack(\"&lt;i\", reader.read(4))[0]\n            for i in range(entries):\n                entry = {\n                    \"BinaryType\": struct.unpack(\"i\", reader.read(4))[0],\n                    \"DeviceType\": struct.unpack(\"i\", reader.read(4))[0],\n                    \"PartitionID\": struct.unpack(\"i\", reader.read(4))[0],\n                    \"Attributes\": struct.unpack(\"i\", reader.read(4))[0],\n                    \"UpdateAttributes\": struct.unpack(\"i\", reader.read(4))[0],\n                    \"BlockSize\": struct.unpack(\"i\", reader.read(4))[0],\n                    \"BlockCount\": struct.unpack(\"i\", reader.read(4))[0],\n                    \"FileOffset\": struct.unpack(\"i\", reader.read(4))[0],\n                    \"FileSize\": struct.unpack(\"i\", reader.read(4))[0],\n                    \"Partition\": reader.read(32)\n                    .decode(\"utf-8\")\n                    .strip()\n                    .strip(\"\\x20\")\n                    .strip(\"\\x00\"),\n                    \"FileName\": reader.read(32)\n                    .decode(\"utf-8\")\n                    .strip()\n                    .strip(\"\\x20\")\n                    .strip(\"\\x00\"),\n                    \"DeltaName\": reader.read(32)\n                    .decode(\"utf-8\")\n                    .strip()\n                    .strip(\"\\x20\")\n                    .strip(\"\\x00\"),\n                }\n                self.partitions[entry[\"Partition\"]] = entry\n\n    def flash(\n        self,\n        stream: BytesIO,\n        entry: str,\n        progress_callback,\n        update_bootloader=False,\n        efs_clear=False,\n    ):\n        \"\"\"\n        Flash a file to device.\n\n        Arguments:\n\n        - `stream`: An open file stream\n        - `entry`: Partition name\n        - `progress_callback`: Callback for progress.\n        - `update_bootloader` (optional)\n        - `efs_clear` (optional)\n        \"\"\"\n\n        def get_size(s):\n            s.seek(0, 2)\n            size = s.tell()\n            s.seek(0)\n            return size\n\n        if not self.partitions:\n            self.get_pit()\n        entry = self.partitions[entry]\n        length = get_size(stream)\n        self.send_total_bytes(length)\n        buf = bytearray(1024)\n        self.pack(0x66, 0, buf)\n        self.pack(0x00, 4, buf)\n        self.write(buf)\n        self.read()\n        sequence = self.flashpacketsize * self.sequencesize\n        sequences = length // sequence\n        last_sequence = length % sequence\n        if last_sequence != 0:\n            sequences += 1\n        else:\n            last_sequence = sequence\n        for i in range(sequences):\n            if i + 1 == sequences:\n                last = True\n            real_size = last_sequence if last else sequence\n            aligned_size = real_size\n            if real_size % self.flashpacketsize != 0:\n                aligned_size += self.flashpacketsize - real_size % self.flashpacketsize\n            buf = bytearray(1024)\n            self.pack(0x66, 0, buf)\n            self.pack(0x02, 4, buf)\n            self.pack(aligned_size, 8, buf)\n            self.write(buf)\n            self.read()\n            parts = aligned_size // self.flashpacketsize\n            for j in range(parts):\n                buf = bytearray(self.flashpacketsize)\n                stream.readinto(buf)\n                self.write(buf)\n                ret = self.read()\n                index = ret[4]\n                if index != j:\n                    logging.warning(\"Bootloader index is wrong!\")\n                progress_callback((j / parts) * 100)\n            progress_callback(100)\n            if entry[\"BinaryType\"] == 1:\n                logging.debug(\"Flashing Modem\")\n                buf = bytearray(1024)\n                self.pack(0x66, 0, buf)\n                self.pack(0x03, 4, buf)\n                self.pack(0x01, 8, buf)\n                self.pack(real_size, 12, buf)\n                self.pack(entry[\"BinaryType\"], 16, buf)\n                self.pack(entry[\"DeviceType\"], 20, buf)\n                self.pack(1 if last else 0, 24, buf)\n                self.write(buf)\n            else:\n                logging.debug(\"Flashing firmware\")\n                buf = bytearray(1024)\n                self.pack(0x66, 0, buf)\n                self.pack(0x03, 4, buf)\n                self.pack(0x00, 8, buf)\n                self.pack(real_size, 12, buf)\n                self.pack(entry[\"BinaryType\"], 16, buf)\n                self.pack(entry[\"DeviceType\"], 20, buf)\n                self.pack(entry[\"PartitionID\"], 24, buf)\n                self.pack(1 if last else 0, 28, buf)\n                self.pack(1 if efs_clear else 0, 32, buf)\n                self.pack(1 if update_bootloader else 0, 36, buf)\n                self.write(buf)\n            self.read(timeout=120000)\n\n    def send_total_bytes(self, size: int):\n        \"\"\"\n        Send the total size of the files being flashed.\n        Required before flashing.\n\n        Arguments:\n\n        - `size`: Total size in bytes of files\n        \"\"\"\n        buf = bytearray(1024)\n        self.pack(0x64, 0, buf)\n        self.pack(0x02, 4, buf)\n        self.pack(size, 8, buf)\n        self.write(buf)\n        self.read()\n\n    def begin_session(self, resume=False):\n        \"\"\"\n        Begin a ODIN session\n\n        - `resume`: Are we resuming from a previous session?\n        \"\"\"\n        self.session_started = True\n        if not resume:\n            try:\n                self.write(\"ODIN\")\n                ret = self.read()\n            except USBTimeoutError:\n                self.session_started = False\n                raise ValueError(\"Error starting session\")\n            if ret.tobytes().decode(\"utf-8\") != \"LOKE\":\n                raise ValueError(f\"Expected LOKE; Got {ret.tobytes().decode('utf-8')}\")\n        buf = bytearray(1024)\n        self.pack(0x64, 0, buf)\n        self.pack(0x00, 4, buf)\n        self.pack(0xFFFF, 8, buf)\n        self.write(buf)\n        ret = self.read()\n        version = ret[6]\n        logging.debug(f\"BL Version: {version}\")\n        # Send file size\n        if version in {0, 1}:\n            self.flashpacketsize = 131072\n            self.sequencesize = 240\n        else:\n            self.flashpacketsize = 1048576\n            self.sequencesize = 30\n        buf = bytearray(1024)\n        self.pack(0x64, 0, buf)\n        self.pack(0x05, 4, buf)\n        self.pack(self.flashpacketsize, 8, buf)\n        self.write(buf)\n        self.read()\n        print(\"Successfully began a session!\")\n    def enable_tflash(self):\n        \"\"\"\n        Enable T-Flash\n        \"\"\"\n        buf = bytearray(1024)\n        self.pack(0x64, 0, buf)\n        self.pack(0x08, 4, buf)\n        self.write(buf)\n        self.read(timeout=600000)\n        self.t_flash_enabled = True\n    def reboot(self):\n        \"\"\"\n        Reboot the device\n        \"\"\"\n        # Do this to be safe\n        self.end_session()\n        buf = bytearray(1024)\n        self.pack(0x67, 0, buf)\n        self.pack(0x01, 4, buf)\n        self.write(buf)\n        # Reboot\n        self.read()\n        self.dev = None\n        self.partitions = {}\n\n    def shutdown(self):\n        \"\"\"\n        Shutdown the device. Doesn't work on some devices.\n        \"\"\"\n        buf = bytearray(1024)\n        self.pack(0x67, 0, buf)\n        self.pack(0x03, 4, buf)\n        self.write(buf)\n        self.read()\n        self.dev = None\n        self.partitions = {}\n\n    def end_session(self):\n        \"\"\"\n        End ODIN session\n        \"\"\"\n        buf = bytearray(1024)\n        self.pack(0x67, 0, buf)\n        self.pack(0x00, 4, buf)\n        self.write(buf)\n        self.read()\n\n    def flash_file(self, file: str, partition: str, callback):\n        \"\"\"\n        Wrapper around flash function.\n\n        Arguments:\n\n        - `file`: Relative path to file\n\n        - `partition`: Partition to flash\n\n        - `callback`: Progress callback\n\n        !!! example\n            ```python\n            # This should be structured better...\n            from pythor import PyThor\n            def callback(percent):\n                print(f\"{percent}% done\")\n            FlashTool = PyThor()\n            FlashTool.connect()\n            FlashTool.begin_session()\n            FlashTool.flash_file(\"/path/to/file\", \"RECOVERY\", callback)\n            ```\n        \"\"\"\n        # Check if file exists\n        if os.path.exists(file):\n            with open(file, \"rb\") as stream:\n                self.flash(stream, partition, callback)\n        else:\n            logging.error(\"That file doesn't exist\")\n\n    def factory_reset(self):\n        \"\"\"\n        Factory reset the device (erase userdata)\n        \"\"\"\n        buf = bytearray(1024)\n        self.pack(0x64, 0, buf)\n        self.pack(0x07, 4, buf)\n        self.write(buf)\n        self.read(timeout=600000)\n</code></pre>"},{"location":"reference/#pythor.PyThor.begin_session","title":"<code>begin_session(resume=False)</code>","text":"<p>Begin a ODIN session</p> <ul> <li><code>resume</code>: Are we resuming from a previous session?</li> </ul> Source code in <code>pythor/pythor.py</code> <pre><code>def begin_session(self, resume=False):\n    \"\"\"\n    Begin a ODIN session\n\n    - `resume`: Are we resuming from a previous session?\n    \"\"\"\n    self.session_started = True\n    if not resume:\n        try:\n            self.write(\"ODIN\")\n            ret = self.read()\n        except USBTimeoutError:\n            self.session_started = False\n            raise ValueError(\"Error starting session\")\n        if ret.tobytes().decode(\"utf-8\") != \"LOKE\":\n            raise ValueError(f\"Expected LOKE; Got {ret.tobytes().decode('utf-8')}\")\n    buf = bytearray(1024)\n    self.pack(0x64, 0, buf)\n    self.pack(0x00, 4, buf)\n    self.pack(0xFFFF, 8, buf)\n    self.write(buf)\n    ret = self.read()\n    version = ret[6]\n    logging.debug(f\"BL Version: {version}\")\n    # Send file size\n    if version in {0, 1}:\n        self.flashpacketsize = 131072\n        self.sequencesize = 240\n    else:\n        self.flashpacketsize = 1048576\n        self.sequencesize = 30\n    buf = bytearray(1024)\n    self.pack(0x64, 0, buf)\n    self.pack(0x05, 4, buf)\n    self.pack(self.flashpacketsize, 8, buf)\n    self.write(buf)\n    self.read()\n    print(\"Successfully began a session!\")\n</code></pre>"},{"location":"reference/#pythor.PyThor.connect","title":"<code>connect()</code>","text":"<p>Connects to Samsung Device</p> Source code in <code>pythor/pythor.py</code> <pre><code>def connect(self):\n    \"\"\"Connects to Samsung Device\"\"\"\n    self.dev = usb.core.find(idVendor=0x04E8)\n    if self.dev is None:\n        raise ValueError(\"Could not find a Samsung device\")\n    self.dev.set_configuration()\n</code></pre>"},{"location":"reference/#pythor.PyThor.enable_tflash","title":"<code>enable_tflash()</code>","text":"<p>Enable T-Flash</p> Source code in <code>pythor/pythor.py</code> <pre><code>def enable_tflash(self):\n    \"\"\"\n    Enable T-Flash\n    \"\"\"\n    buf = bytearray(1024)\n    self.pack(0x64, 0, buf)\n    self.pack(0x08, 4, buf)\n    self.write(buf)\n    self.read(timeout=600000)\n    self.t_flash_enabled = True\n</code></pre>"},{"location":"reference/#pythor.PyThor.end_session","title":"<code>end_session()</code>","text":"<p>End ODIN session</p> Source code in <code>pythor/pythor.py</code> <pre><code>def end_session(self):\n    \"\"\"\n    End ODIN session\n    \"\"\"\n    buf = bytearray(1024)\n    self.pack(0x67, 0, buf)\n    self.pack(0x00, 4, buf)\n    self.write(buf)\n    self.read()\n</code></pre>"},{"location":"reference/#pythor.PyThor.factory_reset","title":"<code>factory_reset()</code>","text":"<p>Factory reset the device (erase userdata)</p> Source code in <code>pythor/pythor.py</code> <pre><code>def factory_reset(self):\n    \"\"\"\n    Factory reset the device (erase userdata)\n    \"\"\"\n    buf = bytearray(1024)\n    self.pack(0x64, 0, buf)\n    self.pack(0x07, 4, buf)\n    self.write(buf)\n    self.read(timeout=600000)\n</code></pre>"},{"location":"reference/#pythor.PyThor.flash","title":"<code>flash(stream, entry, progress_callback, update_bootloader=False, efs_clear=False)</code>","text":"<p>Flash a file to device.</p> <p>Arguments:</p> <ul> <li><code>stream</code>: An open file stream</li> <li><code>entry</code>: Partition name</li> <li><code>progress_callback</code>: Callback for progress.</li> <li><code>update_bootloader</code> (optional)</li> <li><code>efs_clear</code> (optional)</li> </ul> Source code in <code>pythor/pythor.py</code> <pre><code>def flash(\n    self,\n    stream: BytesIO,\n    entry: str,\n    progress_callback,\n    update_bootloader=False,\n    efs_clear=False,\n):\n    \"\"\"\n    Flash a file to device.\n\n    Arguments:\n\n    - `stream`: An open file stream\n    - `entry`: Partition name\n    - `progress_callback`: Callback for progress.\n    - `update_bootloader` (optional)\n    - `efs_clear` (optional)\n    \"\"\"\n\n    def get_size(s):\n        s.seek(0, 2)\n        size = s.tell()\n        s.seek(0)\n        return size\n\n    if not self.partitions:\n        self.get_pit()\n    entry = self.partitions[entry]\n    length = get_size(stream)\n    self.send_total_bytes(length)\n    buf = bytearray(1024)\n    self.pack(0x66, 0, buf)\n    self.pack(0x00, 4, buf)\n    self.write(buf)\n    self.read()\n    sequence = self.flashpacketsize * self.sequencesize\n    sequences = length // sequence\n    last_sequence = length % sequence\n    if last_sequence != 0:\n        sequences += 1\n    else:\n        last_sequence = sequence\n    for i in range(sequences):\n        if i + 1 == sequences:\n            last = True\n        real_size = last_sequence if last else sequence\n        aligned_size = real_size\n        if real_size % self.flashpacketsize != 0:\n            aligned_size += self.flashpacketsize - real_size % self.flashpacketsize\n        buf = bytearray(1024)\n        self.pack(0x66, 0, buf)\n        self.pack(0x02, 4, buf)\n        self.pack(aligned_size, 8, buf)\n        self.write(buf)\n        self.read()\n        parts = aligned_size // self.flashpacketsize\n        for j in range(parts):\n            buf = bytearray(self.flashpacketsize)\n            stream.readinto(buf)\n            self.write(buf)\n            ret = self.read()\n            index = ret[4]\n            if index != j:\n                logging.warning(\"Bootloader index is wrong!\")\n            progress_callback((j / parts) * 100)\n        progress_callback(100)\n        if entry[\"BinaryType\"] == 1:\n            logging.debug(\"Flashing Modem\")\n            buf = bytearray(1024)\n            self.pack(0x66, 0, buf)\n            self.pack(0x03, 4, buf)\n            self.pack(0x01, 8, buf)\n            self.pack(real_size, 12, buf)\n            self.pack(entry[\"BinaryType\"], 16, buf)\n            self.pack(entry[\"DeviceType\"], 20, buf)\n            self.pack(1 if last else 0, 24, buf)\n            self.write(buf)\n        else:\n            logging.debug(\"Flashing firmware\")\n            buf = bytearray(1024)\n            self.pack(0x66, 0, buf)\n            self.pack(0x03, 4, buf)\n            self.pack(0x00, 8, buf)\n            self.pack(real_size, 12, buf)\n            self.pack(entry[\"BinaryType\"], 16, buf)\n            self.pack(entry[\"DeviceType\"], 20, buf)\n            self.pack(entry[\"PartitionID\"], 24, buf)\n            self.pack(1 if last else 0, 28, buf)\n            self.pack(1 if efs_clear else 0, 32, buf)\n            self.pack(1 if update_bootloader else 0, 36, buf)\n            self.write(buf)\n        self.read(timeout=120000)\n</code></pre>"},{"location":"reference/#pythor.PyThor.flash_file","title":"<code>flash_file(file, partition, callback)</code>","text":"<p>Wrapper around flash function.</p> <p>Arguments:</p> <ul> <li> <p><code>file</code>: Relative path to file</p> </li> <li> <p><code>partition</code>: Partition to flash</p> </li> <li> <p><code>callback</code>: Progress callback</p> </li> </ul> <p>Example</p> <pre><code># This should be structured better...\nfrom pythor import PyThor\ndef callback(percent):\n    print(f\"{percent}% done\")\nFlashTool = PyThor()\nFlashTool.connect()\nFlashTool.begin_session()\nFlashTool.flash_file(\"/path/to/file\", \"RECOVERY\", callback)\n</code></pre> Source code in <code>pythor/pythor.py</code> <pre><code>def flash_file(self, file: str, partition: str, callback):\n    \"\"\"\n    Wrapper around flash function.\n\n    Arguments:\n\n    - `file`: Relative path to file\n\n    - `partition`: Partition to flash\n\n    - `callback`: Progress callback\n\n    !!! example\n        ```python\n        # This should be structured better...\n        from pythor import PyThor\n        def callback(percent):\n            print(f\"{percent}% done\")\n        FlashTool = PyThor()\n        FlashTool.connect()\n        FlashTool.begin_session()\n        FlashTool.flash_file(\"/path/to/file\", \"RECOVERY\", callback)\n        ```\n    \"\"\"\n    # Check if file exists\n    if os.path.exists(file):\n        with open(file, \"rb\") as stream:\n            self.flash(stream, partition, callback)\n    else:\n        logging.error(\"That file doesn't exist\")\n</code></pre>"},{"location":"reference/#pythor.PyThor.get_pit","title":"<code>get_pit()</code>","text":"<p>Read PIT from device</p> <p>Returns:</p> Name Type Description <code>pit_data</code> <code>bytearray</code> <p>PIT Data</p> Source code in <code>pythor/pythor.py</code> <pre><code>def get_pit(self):\n    \"\"\"\n    Read PIT from device\n\n    Returns:\n        pit_data (bytearray): PIT Data\n    \"\"\"\n    # Request PIT dump\n    buf = bytearray(1024)\n    self.pack(0x65, 0, buf)\n    self.pack(0x01, 4, buf)\n    self.write(buf)\n    ret = self.read()\n    size = struct.unpack_from(\"&lt;I\", ret, 4)[0]\n    blocks = math.ceil(size / 500)\n    logging.debug(f\"PIT size is {size}, {blocks} total blocks\")\n    pit_buf = bytearray(size)\n    for i in range(blocks):\n        buf = bytearray(1024)\n        self.pack(0x65, 0, buf)\n        self.pack(0x02, 4, buf)\n        self.pack(i, 8, buf)\n        self.write(buf)\n        ret = self.read()\n        pit_buf[i * 500 : i * 500 + len(ret)] = ret\n    # Send PIT finish\n    buf = bytearray(1024)\n    self.pack(0x65, 0, buf)\n    self.pack(0x03, 4, buf)\n    # Read ZLP\n    try:\n        self.read()\n    except usb.USBError:\n        # This is fine.\n        pass\n    self.write(buf)\n    self.read()\n    self.parse_pit(pit_buf)\n    return pit_buf\n</code></pre>"},{"location":"reference/#pythor.PyThor.pack","title":"<code>pack(data, offset, buf)</code>","text":"<p>Packs data into buffer</p> <ul> <li><code>data</code>: The data to add to buffer</li> <li><code>offset</code>: Offset of the data in the buffer</li> <li><code>buf</code>: Buffer to add data to.</li> </ul> Source code in <code>pythor/pythor.py</code> <pre><code>def pack(self, data, offset, buf):\n    \"\"\"\n    Packs data into buffer\n\n    - `data`: The data to add to buffer\n    - `offset`: Offset of the data in the buffer\n    - `buf`: Buffer to add data to.\n    \"\"\"\n    struct.pack_into(\"i\", buf, offset, data)\n</code></pre>"},{"location":"reference/#pythor.PyThor.parse_pit","title":"<code>parse_pit(pit)</code>","text":"<p>Parse PIT</p> <p>Arguments:</p> <ul> <li><code>pit</code>: Pit data.</li> </ul> Source code in <code>pythor/pythor.py</code> <pre><code>def parse_pit(self, pit: bytearray):\n    \"\"\"\n    Parse PIT\n\n    Arguments:\n\n    - `pit`: Pit data.\n    \"\"\"\n    with BytesIO(pit) as reader:\n        magic_number = struct.unpack(\"&lt;I\", reader.read(4))[0]\n        if magic_number != 0x12349876:\n            raise ValueError(\"Magic Number Mismatch\")\n        entries = struct.unpack(\"&lt;I\", reader.read(4))[0]\n        unknown = reader.read(8).decode(\"utf-8\")\n        project = reader.read(8).decode(\"utf-8\")\n        reserved = struct.unpack(\"&lt;i\", reader.read(4))[0]\n        for i in range(entries):\n            entry = {\n                \"BinaryType\": struct.unpack(\"i\", reader.read(4))[0],\n                \"DeviceType\": struct.unpack(\"i\", reader.read(4))[0],\n                \"PartitionID\": struct.unpack(\"i\", reader.read(4))[0],\n                \"Attributes\": struct.unpack(\"i\", reader.read(4))[0],\n                \"UpdateAttributes\": struct.unpack(\"i\", reader.read(4))[0],\n                \"BlockSize\": struct.unpack(\"i\", reader.read(4))[0],\n                \"BlockCount\": struct.unpack(\"i\", reader.read(4))[0],\n                \"FileOffset\": struct.unpack(\"i\", reader.read(4))[0],\n                \"FileSize\": struct.unpack(\"i\", reader.read(4))[0],\n                \"Partition\": reader.read(32)\n                .decode(\"utf-8\")\n                .strip()\n                .strip(\"\\x20\")\n                .strip(\"\\x00\"),\n                \"FileName\": reader.read(32)\n                .decode(\"utf-8\")\n                .strip()\n                .strip(\"\\x20\")\n                .strip(\"\\x00\"),\n                \"DeltaName\": reader.read(32)\n                .decode(\"utf-8\")\n                .strip()\n                .strip(\"\\x20\")\n                .strip(\"\\x00\"),\n            }\n            self.partitions[entry[\"Partition\"]] = entry\n</code></pre>"},{"location":"reference/#pythor.PyThor.print_pit","title":"<code>print_pit()</code>","text":"<p>Print PIT of device</p> Source code in <code>pythor/pythor.py</code> <pre><code>def print_pit(self):\n    \"\"\"Print PIT of device\"\"\"\n    tree = Tree()\n    root = tree.create_node(\"Partitions\")\n    if not self.partitions:\n        self.get_pit()\n    for partition, attributes in self.partitions.items():\n        node = tree.create_node(partition, parent=root)\n        for key, value in attributes.items():\n            tree.create_node(f\"{key}: {value}\", parent=node)\n    print(tree.show(stdout=False))\n</code></pre>"},{"location":"reference/#pythor.PyThor.read","title":"<code>read(timeout=None)</code>","text":"<p>Read data from device</p> <ul> <li><code>timeout</code> (optional): read timeout in ms.</li> </ul> Source code in <code>pythor/pythor.py</code> <pre><code>def read(self, timeout: int = None):\n    \"\"\"\n    Read data from device\n\n    - `timeout` (optional): read timeout in ms.\n    \"\"\"\n    if self.dev and self.session_started:\n        ret = self.dev.read(0x81, 0x1000, timeout)\n        return ret\n    else:\n        raise ValueError(\"You need to start a session first\")\n</code></pre>"},{"location":"reference/#pythor.PyThor.reboot","title":"<code>reboot()</code>","text":"<p>Reboot the device</p> Source code in <code>pythor/pythor.py</code> <pre><code>def reboot(self):\n    \"\"\"\n    Reboot the device\n    \"\"\"\n    # Do this to be safe\n    self.end_session()\n    buf = bytearray(1024)\n    self.pack(0x67, 0, buf)\n    self.pack(0x01, 4, buf)\n    self.write(buf)\n    # Reboot\n    self.read()\n    self.dev = None\n    self.partitions = {}\n</code></pre>"},{"location":"reference/#pythor.PyThor.send_total_bytes","title":"<code>send_total_bytes(size)</code>","text":"<p>Send the total size of the files being flashed. Required before flashing.</p> <p>Arguments:</p> <ul> <li><code>size</code>: Total size in bytes of files</li> </ul> Source code in <code>pythor/pythor.py</code> <pre><code>def send_total_bytes(self, size: int):\n    \"\"\"\n    Send the total size of the files being flashed.\n    Required before flashing.\n\n    Arguments:\n\n    - `size`: Total size in bytes of files\n    \"\"\"\n    buf = bytearray(1024)\n    self.pack(0x64, 0, buf)\n    self.pack(0x02, 4, buf)\n    self.pack(size, 8, buf)\n    self.write(buf)\n    self.read()\n</code></pre>"},{"location":"reference/#pythor.PyThor.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the device. Doesn't work on some devices.</p> Source code in <code>pythor/pythor.py</code> <pre><code>def shutdown(self):\n    \"\"\"\n    Shutdown the device. Doesn't work on some devices.\n    \"\"\"\n    buf = bytearray(1024)\n    self.pack(0x67, 0, buf)\n    self.pack(0x03, 4, buf)\n    self.write(buf)\n    self.read()\n    self.dev = None\n    self.partitions = {}\n</code></pre>"},{"location":"reference/#pythor.PyThor.write","title":"<code>write(data)</code>","text":"<p>Writes data to device</p> <ul> <li><code>data</code>: Data to send to device</li> </ul> Source code in <code>pythor/pythor.py</code> <pre><code>def write(self, data):\n    \"\"\"\n    Writes data to device\n\n    - `data`: Data to send to device\n    \"\"\"\n    if self.dev and self.session_started:\n        self.dev.write(0x1, data)\n    else:\n        raise ValueError(\"You need to start a session first\")\n</code></pre>"}]}